# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    cube.txt                                           :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: broboeuf <broboeuf@student.42.fr>          +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2025/07/18 20:27:03 by broboeuf          #+#    #+#              #
#    Updated: 2025/07/18 23:23:45 by broboeuf         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

#ifndef CUB3D_H
# define CUB3D_H

# include "./../lib/lib.h"
# include "./../minilibx-linux/mlx.h"
# include <fcntl.h>
# include <math.h>
# include <stdio.h>
# include <unistd.h>
/* --- Constantes mathématiques --- */
# ifndef M_PI
#  define M_PI 3.14159265358979323846
# endif

# ifndef M_PI_2
#  define M_PI_2 1.57079632679489661923
# endif

# ifndef M_PI_4
#  define M_PI_4 0.78539816339744830962
# endif

# ifndef M_2_PI
#  define M_2_PI 6.28318530717958647692
# endif

/* --- Dimensions du jeu --- */
# define WIDTH 1280
# define HEIGHT 720
# define CUBE_SIZE 64
# define MINI_SIZE 8
# define PLAYER_HEIGHT 32
# define PROJECTION_DISTANCE 1108

/* --- Champs de vision --- */
# define FOV 60
# define HALF_FOV 30
# define DEG_RAD 0.017453
# define RAD_DEG 57.295780
# define TWO_PI 6.283185
# define PI_3_2 4.712389
# define ANGLE_INCR 0.001636

/* --- Paramètres du joueur --- */
# define SPEED 10.0
# define ROT_SPEED 0.06

/* --- Contrôles clavier --- */
# define LEFT_ARROW 65361
# define RIGHT_ARROW 65363
# define FORWARD 119  // W
# define BACKWARD 115 // S
# define LEFT 97      // A
# define RIGHT 100    // D
# define ESC 65307    // Escape

/* --- Nombre de rayons --- */
# define NB_RAYS 640

/* --- Direction des murs --- */
enum					e_direction
{
	NORTH,
	SOUTH,
	EAST,
	WEST
};

/* --- Point simple en 2D --- */
typedef struct s_point
{
	int					x;
	int					y;
}						t_point;

/* --- Données d'une image MLX --- */
typedef struct s_image
{
	void				*img;
	char				*addr;
	int					bpp;
	int					line_len;
	int					endian;
}						t_image;

/* --- Texture de mur --- */
typedef struct s_texture
{
	void				*img;
	char				*addr;
	int					bpp;
	int					line_len;
	int					endian;
	int					width;
	int					height;
	int					is_init;
}						t_texture;

/* --- Informations sur un rayon projeté --- */
typedef struct s_ray
{
	t_point				point;
	float				distance;
	double				angle;
	float				wall_height;
	int					axis;
	double				height;
	enum e_direction	face;
}						t_ray;

/* --- Variables pour le calcul DDA --- */
typedef struct s_ray_calc
{
	double				angle_sin;
	double				angle_cos;
	double				delta_x;
	double				delta_y;
	double				x;
	double				y;
}						t_ray_calc;

/* --- Joueur --- */
typedef struct s_player
{
	t_point				map_pos;
	double				dir;
	double				speed;
}						t_player;

/* --- Structure principale du jeu --- */
typedef struct s_game
{
	void				*mlx;
	void				*win;
	t_image				screen;
	t_texture			*tex_north;
	t_texture			*tex_south;
	t_texture			*tex_west;
	t_texture			*tex_east;
	int					floor_color;
	int					ceiling_color;
	int					map_width;
	int					map_height;
	char				**map;
	t_ray				*rays;
	t_player			player;
}						t_game;

void					ft_draw_line(t_image *img, t_point p1, t_point p2,
							int col);
double					normalize_angle(double angle);
void					draw_slice(t_game *game, t_ray ray, int index);
void					draw_frame(t_game *game);
int						coords_within_boundaries(t_game *game, int x, int y);
int						is_wall(t_game *game, int x, int y);
void					fill_ray_vertical(t_ray *ray, t_game *game,
							t_ray_calc calc, int right);
void					fill_ray_horizontal(t_ray *ray, t_ray_calc calc,
							int up);
double					get_wall_y(t_ray_calc calc, int up);
void					cast_ray(t_game *game, double ray_angle, t_ray *ray);
int						load_texture(t_game *game, t_texture *tex, char *path);
int						get_tex_color(t_texture *tex, int x, int y);
int						create_color(int t, int r, int g, int b);
void					game_loop(t_game *game);
void					put_pixel(t_image *img, int x, int y, int color);
int						add_texture(t_game *game, char *line);
void					get_player_start(t_game *game);
int						add_color(t_game *game, char *line);
int						textures_colors_complete(t_game *game);
int						map_have_one_player(char **map);
int						valid_surroundings(char **map, int i, int j);
int						is_map_closed(char **map);
int						parse_map(char *path, t_game *game);
int						is_blocking_down(t_game *game, int new_x, int new_y);
int						is_blocking_up(t_game *game, int new_x, int new_y);
int						is_blocking_right(t_game *game, int new_x, int new_y);
int						is_blocking_left(t_game *game, int new_x, int new_y);
int						print_error(char *str, int exit_status);
int						is_file_extension_correct(char *filename);
int						free_game(t_game *game);
int						free_allocated_array(char ***array, int is_err);
int						free_textures(t_game *game);
void					free_partial(char ***array, int last_alloc);
int						init_tex_north(t_game *game);
int						init_tex_south(t_game *game);
int						init_tex_east(t_game *game);
int						init_tex_west(t_game *game);
int						is_player_char(char c);
int						is_map_char(char c);
int						is_map_line(char *line);
int						init_game_data(t_game *game);
int						init_map_array(t_game *game, int height, int width);
void					move_player_forward(t_game *game);
void					move_player_backward(t_game *game);
void					move_player_left(t_game *game);
void					move_player_right(t_game *game);
unsigned int			strlen_without_nl(const char *str);
char					*strdup_trimmed(const char *str);
int						string_array_length(char **array);

#endif

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   bressenham.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: broboeuf <broboeuf@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/18 20:43:05 by broboeuf          #+#    #+#             */
/*   Updated: 2025/07/18 22:04:45 by broboeuf         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cube3d.h"

/**
 * Rend la valeur absolue de *d et ajuste le signe de l'incrément *i
 * @param d pointeur vers la valeur delta
 * @param i pointeur vers l’incrément
 */
static void	absolute(int *d, int *i)
{
	if (*d < 0)
	{
		*i = -1;
		*d = -(*d);
	}
}

/**
 * Trace une ligne avec pente faible (plus horizontale que verticale)
 * @param img image cible
 * @param p1 point de départ
 * @param p2 point d’arrivée
 * @param col couleur
 */
static void	draw_seg_low(t_image *img, t_point p1, t_point p2, int col)
{
	int	dy;
	int	yi;
	int	derive;
	int	x;
	int	y;

	dy = p2.y - p1.y;
	yi = 1;
	absolute(&dy, &yi);
	derive = (2 * dy) - (p2.x - p1.x);
	x = p1.x;
	y = p1.y;
	while (x < p2.x)
	{
		put_pixel(img, x, y, col);
		if (derive > 0)
		{
			y += yi;
			derive += 2 * (dy - (p2.x - p1.x));
		}
		else
			derive += 2 * dy;
		x++;
	}
}

/**
 * Trace une ligne avec pente forte (plus verticale qu’horizontale)
 * @param img image cible
 * @param p1 point de départ
 * @param p2 point d’arrivée
 * @param col couleur
 */
static void	draw_seg_high(t_image *img, t_point p1, t_point p2, int col)
{
	int	dx;
	int	xi;
	int	derive;
	int	y;
	int	x;

	dx = p2.x - p1.x;
	xi = 1;
	absolute(&dx, &xi);
	derive = (2 * dx) - (p2.y - p1.y);
	y = p1.y;
	x = p1.x;
	while (y < p2.y)
	{
		put_pixel(img, x, y, col);
		if (derive > 0)
		{
			x += xi;
			derive += 2 * (dx - (p2.y - p1.y));
		}
		else
			derive += 2 * dx;
		y++;
	}
}

/**
 * Trace une ligne entre deux points en utilisant l’algorithme de Bresenham
 * @param img image cible
 * @param p1 point de départ
 * @param p2 point d’arrivée
 * @param col couleur de la ligne
 */
void	ft_draw_line(t_image *img, t_point p1, t_point p2, int col)
{
	if (abs(p2.y - p1.y) < abs(p2.x - p1.x))
	{
		if (p1.x > p2.x)
			draw_seg_low(img, p2, p1, col);
		else
			draw_seg_low(img, p1, p2, col);
	}
	else
	{
		if (p1.y > p2.y)
			draw_seg_high(img, p2, p1, col);
		else
			draw_seg_high(img, p1, p2, col);
	}
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   calculate.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: broboeuf <broboeuf@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/18 20:50:46 by broboeuf          #+#    #+#             */
/*   Updated: 2025/07/18 23:13:58 by broboeuf         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cube3d.h"

/**
 * Normalise un angle en radians dans l’intervalle [0 ; 2π)
 *
 * @param angle angle à normaliser (en radians)
 * @return angle normalisé
 */
double	normalize_angle(double angle)
{
	if (angle >= TWO_PI)
		angle -= TWO_PI;
	if (angle < 0.0)
		angle += TWO_PI;
	return (angle);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   trace.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: broboeuf <broboeuf@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/18 20:43:46 by broboeuf          #+#    #+#             */
/*   Updated: 2025/07/18 20:58:57 by broboeuf         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cube3d.h"

/**
 * Retourne la texture correspondant à la face du mur touchée
 * @param game structure principale
 * @param side direction de la face (NORTH, SOUTH, etc.)
 * @return pointeur vers la texture correspondante
 */
static t_texture	*get_texture(t_game *game, enum e_direction side)
{
	if (side == NORTH)
		return (game->tex_north);
	else if (side == SOUTH)
		return (game->tex_south);
	else if (side == EAST)
		return (game->tex_east);
	else
		return (game->tex_west);
}

/**
 * Dessine une colonne de texture à l’écran
 * @param game structure du jeu
 * @param ray données du rayon
 * @param x position x de la colonne
 * @param offset décalage vertical pour centrer le mur
 */
static void	draw_texture_column(t_game *game, t_ray ray, int x, int offset)
{
	t_texture	*tex;
	float		scale;
	int			tex_x;
	float		tex_y;
	int			y;

	tex = get_texture(game, ray.face);
	scale = tex->height / ray.height;
	tex_x = (ray.axis == 1) ? ray.point.y % CUBE_SIZE : ray.point.x % CUBE_SIZE;
	tex_y = (ray.height > HEIGHT) ? ((ray.height - HEIGHT) / 2) * scale : 0;
	y = 0;
	while (y < ray.height)
	{
		put_pixel(&game->screen, x, y + offset, get_tex_color(tex, tex_x,
				(int)tex_y % tex->height));
		tex_y += scale;
		y++;
	}
}

/**
 * Dessine une tranche verticale de l’écran : plafond, mur, sol
 * @param game structure principale
 * @param ray données du rayon correspondant à cette colonne
 * @param index position x à l’écran
 */
void	draw_slice(t_game *game, t_ray ray, int index)
{
	int	i;
	int	offset;

	offset = (HEIGHT - ray.height) / 2;
	if (offset < 0)
		offset = 0;
	i = 0;
	while (i < offset)
	{
		put_pixel(&game->screen, index, i, game->ceiling_color);
		i++;
	}
	draw_texture_column(game, ray, index, i);
	i = ray.height + offset;
	while (i < HEIGHT)
	{
		put_pixel(&game->screen, index, i, game->floor_color);
		i++;
	}
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   frame.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: broboeuf <broboeuf@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/18 20:41:40 by broboeuf          #+#    #+#             */
/*   Updated: 2025/07/18 20:59:04 by broboeuf         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cube3d.h"

/**
 * Dessine l’image complète colonne par colonne
 * Chaque rayon génère deux colonnes de pixels (2x NB_RAYS)
 * @param game structure principale du jeu
 */
static void	draw_image(t_game *game)
{
	int	i;

	i = 0;
	while (i < NB_RAYS)
	{
		if (game->rays[i].distance > 0)
		{
			draw_slice(game, game->rays[i], 2 * i);
			draw_slice(game, game->rays[i], 2 * i + 1);
		}
		i++;
	}
}

/**
 * Lance NB_RAYS rayons depuis la position du joueur
 * Utilise la fonction de DDA pour détecter les murs
 * Les résultats sont stockés dans game->rays
 * @param game structure principale
 */
static void	raycasting(t_game *game)
{
	int		i;
	double	ray_angle;

	if (game->rays)
		free(game->rays);
	game->rays = malloc(sizeof(t_ray) * NB_RAYS);
	if (!game->rays)
	{
		print_error("malloc failed\n", 0);
		free_game(game);
	}
	ray_angle = game->player.dir - (HALF_FOV * DEG_RAD);
	ray_angle = normalize_angle(ray_angle);
	i = -1;
	while (++i < NB_RAYS)
	{
		cast_ray(game, ray_angle, &game->rays[i]);
		ray_angle += ANGLE_INCR;
		ray_angle = normalize_angle(ray_angle);
	}
}

/**
 * Génère et affiche une frame complète du jeu
 * @param game structure principale
 */
void	draw_frame(t_game *game)
{
	game->screen.img = mlx_new_image(game->mlx, WIDTH, HEIGHT);
	if (!game->screen.img)
		free_game(game);
	game->screen.addr = mlx_get_data_addr(game->screen.img, &game->screen.bpp,
			&game->screen.line_len, &game->screen.endian);
	if (!game->screen.addr)
		free_game(game);
	raycasting(game);
	draw_image(game);
	mlx_put_image_to_window(game->mlx, game->win, game->screen.img, 0, 0);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   raycast_utils.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: broboeuf <broboeuf@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/18 20:37:29 by broboeuf          #+#    #+#             */
/*   Updated: 2025/07/18 22:10:14 by broboeuf         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cube3d.h"

/**
 * Vérifie si des coordonnées sont dans les limites de la carte
 * @param game structure principale
 * @param x position x en pixels
 * @param y position y en pixels
 * @return 1 si valide, 0 sinon
 */
int	coords_within_boundaries(t_game *game, int x, int y)
{
	if (x >= 0 && x < game->map_width * CUBE_SIZE && y >= 0
		&& y < game->map_height * CUBE_SIZE)
		return (1);
	return (0);
}

/**
 * Vérifie si les coordonnées correspondent à un mur
 * @param game structure principale
 * @param x position x en pixels
 * @param y position y en pixels
 * @return 1 si la case est un mur, 0 sinon
 */
int	is_wall(t_game *game, int x, int y)
{
	x = (int)(x / CUBE_SIZE);
	y = (int)(y / CUBE_SIZE);
	if (game->map[y][x] == '1')
		return (1);
	return (0);
}

/**
 * Remplit les infos d’un rayon vertical touché par un mur
 * @param ray structure du rayon
 * @param game structure principale
 * @param calc variables du calcul DDA
 * @param right 1 si le rayon va vers la droite, 0 sinon
 */
void	fill_ray_vertical(t_ray *ray, t_game *game, t_ray_calc calc, int right)
{
	ray->distance = sqrt(pow(calc.x - game->player.map_pos.x, 2) + pow(calc.y
				- game->player.map_pos.y, 2));
	ray->point.x = calc.x;
	ray->point.y = calc.y;
	ray->axis = 1;
	ray->face = right ? WEST : EAST;
}

/**
 * Remplit les infos d’un rayon horizontal touché par un mur
 * @param ray structure du rayon
 * @param calc variables du calcul DDA
 * @param up 1 si le rayon va vers le haut, 0 sinon
 */
void	fill_ray_horizontal(t_ray *ray, t_ray_calc calc, int up)
{
	ray->point.x = calc.x;
	ray->point.y = calc.y;
	ray->axis = 0;
	ray->face = up ? SOUTH : NORTH;
}

/**
 * Calcule approximativement la coordonnée y d’un mur touché
 * @param calc variables du calcul DDA
 * @param up 1 si le rayon monte, 0 sinon
 * @return coordonnée y ajustée
 */
double	get_wall_y(t_ray_calc calc, int up)
{
	if (up)
		return (floor(calc.y - 1));
	else
		return (floor(calc.y));
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   raycast.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: broboeuf <broboeuf@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/18 20:39:00 by broboeuf          #+#    #+#             */
/*   Updated: 2025/07/18 20:59:08 by broboeuf         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cube3d.h"

/**
 * Initialise les variables pour un rayon vertical (DDA)
 * @param r vars du rayon
 * @param game structure principale
 * @param right 1 si le rayon va à droite
 * @return structure mise à jour
 */
static t_ray_calc	get_vertical_calc(t_ray_calc r, t_game *game, int right)
{
	double	slope;

	slope = r.angle_sin / r.angle_cos;
	r.delta_x = right ? 1 : -1;
	r.delta_y = r.delta_x * slope;
	if (right)
		r.x = ceil(game->player.map_pos.x);
	else
		r.x = floor(game->player.map_pos.x);
	r.y = game->player.map_pos.y + (r.x - game->player.map_pos.x) * slope;
	return (r);
}

/**
 * Initialise les variables pour un rayon horizontal (DDA)
 * @param r vars du rayon
 * @param game structure principale
 * @param up 1 si le rayon va vers le haut
 * @return structure mise à jour
 */
static t_ray_calc	get_horizontal_calc(t_ray_calc r, t_game *game, int up)
{
	double	slope;

	slope = r.angle_cos / r.angle_sin;
	r.delta_y = up ? -1 : 1;
	r.delta_x = r.delta_y * slope;
	if (up)
		r.y = floor(game->player.map_pos.y);
	else
		r.y = ceil(game->player.map_pos.y);
	r.x = game->player.map_pos.x + (r.y - game->player.map_pos.y) * slope;
	return (r);
}

/**
 * Recherche du mur vertical touché par le rayon
 * @param r infos de calcul
 * @param game structure du jeu
 * @param ray structure du rayon à remplir
 * @param angle angle du rayon
 */
static void	perform_vertical_dda(t_ray_calc r, t_game *game, t_ray *ray,
		double angle)
{
	int		right;
	double	wall_x;
	double	wall_y;

	right = (angle > PI_3_2 || angle < M_PI_2);
	r = get_vertical_calc(r, game, right);
	while (coords_within_boundaries(game, r.x, r.y))
	{
		wall_x = right ? floor(r.x) : floor(r.x - 1);
		wall_y = floor(r.y);
		if (is_wall(game, wall_x, wall_y))
		{
			fill_ray_vertical(ray, game, r, right);
			break ;
		}
		r.x += r.delta_x;
		r.y += r.delta_y;
	}
}

/**
 * Recherche du mur horizontal touché par le rayon
 * @param r infos de calcul
 * @param game structure du jeu
 * @param ray structure du rayon à remplir
 * @param angle angle du rayon
 */
static void	perform_horizontal_dda(t_ray_calc r, t_game *game, t_ray *ray,
		double angle)
{
	int		up;
	double	wall_x;
	double	wall_y;
	double	dist;

	up = (angle < 0 || angle > M_PI);
	r = get_horizontal_calc(r, game, up);
	while (coords_within_boundaries(game, r.x, r.y))
	{
		wall_y = get_wall_y(r, up);
		wall_x = floor(r.x);
		if (is_wall(game, wall_x, wall_y))
		{
			dist = sqrt(pow(r.x - game->player.map_pos.x, 2) + pow(r.y
						- game->player.map_pos.y, 2));
			if (!ray->distance || dist < ray->distance)
			{
				ray->distance = dist;
				fill_ray_horizontal(ray, r, up);
			}
			break ;
		}
		r.x += r.delta_x;
		r.y += r.delta_y;
	}
}

/**
 * Lance un rayon à partir de l’angle donné avec DDA
 * Stocke la distance et le point de collision dans ray
 * @param game structure du jeu
 * @param ray_angle angle du rayon
 * @param ray structure du rayon à remplir
 */
void	cast_ray(t_game *game, double ray_angle, t_ray *ray)
{
	t_ray_calc	r;
	double		correction;

	ray->distance = 0;
	ray->angle = ray_angle;
	correction = cos(normalize_angle(ray_angle - game->player.dir));
	r.angle_cos = cos(ray_angle);
	r.angle_sin = sin(ray_angle);
	perform_vertical_dda(r, game, ray, ray_angle);
	perform_horizontal_dda(r, game, ray, ray_angle);
	ray->distance *= correction;
	ray->height = CUBE_SIZE / ray->distance * PROJECTION_DISTANCE;
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   mlx_utils.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: broboeuf <broboeuf@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/18 20:28:02 by broboeuf          #+#    #+#             */
/*   Updated: 2025/07/18 20:59:18 by broboeuf         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cube3d.h"

/**
 * Charge une texture depuis un fichier .xpm
 * @param game Structure principale contenant le contexte MLX
 * @param tex Texture à remplir
 * @param path Chemin vers le fichier .xpm
 * @return 1 en cas de succès, 0 sinon
 */
int	load_texture(t_game *game, t_texture *tex, char *path)
{
	tex->img = mlx_xpm_file_to_image(game->mlx, path, &tex->width,
			&tex->height);
	if (!tex->img)
		return (print_error("texture not found\n", 0));
	tex->addr = mlx_get_data_addr(tex->img, &tex->bpp, &tex->line_len,
			&tex->endian);
	if (!tex->addr)
		return (print_error("texture addr not found\n", 0));
	return (1);
}

/**
 * Récupère la couleur d'un pixel d'une texture
 * @param tex Texture source
 * @param x Coordonnée X du pixel
 * @param y Coordonnée Y du pixel
 * @return Couleur du pixel au format int
 */
int	get_tex_color(t_texture *tex, int x, int y)
{
	int	offset;

	if (x < 0 || x >= tex->width)
		return (0);
	if (y < 0 || y >= tex->height)
		return (0);
	offset = y * tex->line_len + x * (tex->bpp / 8);
	return (*(int *)(tex->addr + offset));
}

/**
 * Crée une couleur au format MLX
 * @param t Transparence
 * @param r Rouge
 * @param g Vert
 * @param b Bleu
 * @return Couleur encodée au format MLX
 */
int	create_color(int t, int r, int g, int b)
{
	return ((t << 24) | (r << 16) | (g << 8) | b);
}

/**
 * Gère les actions clavier pendant la partie
 * @param key Touche pressée
 * @param game Structure du jeu
 * @return 0
 */
static int	handle_keys(int key, t_game *game)
{
	if (key == LEFT_ARROW || key == RIGHT_ARROW)
	{
		mlx_destroy_image(game->mlx, game->screen.img);
		if (key == LEFT_ARROW)
			game->player.dir -= ROT_SPEED;
		else
			game->player.dir += ROT_SPEED;
		game->player.dir = normalize_angle(game->player.dir);
		render_scene(game);
	}
	else if (key == FORWARD)
		move_forward(game);
	else if (key == BACKWARD)
		move_backward(game);
	else if (key == LEFT)
		move_left(game);
	else if (key == RIGHT)
		move_right(game);
	if (key == ESC)
		free_game(game);
	return (0);
}

/**
 * Démarre la boucle principale du jeu avec les hooks MLX
 * @param game Structure du jeu
 */
void	game_loop(t_game *game)
{
	mlx_do_key_autorepeaton(game->mlx);
	mlx_hook(game->win, 2, 1L << 0, handle_keys, game);
	mlx_hook(game->win, 17, (1L << 2), free_game, game);
	render_scene(game);
	mlx_loop(game->mlx);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   put_pixel.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: broboeuf <broboeuf@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/18 20:28:51 by broboeuf          #+#    #+#             */
/*   Updated: 2025/07/18 20:59:22 by broboeuf         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cube3d.h"

/**
 * Place un pixel dans l’image à la position (x, y)
 * Ne fait rien si la position est hors de l’écran
 * @param img Image cible (buffer MLX)
 * @param x Coordonnée horizontale
 * @param y Coordonnée verticale
 * @param color Couleur du pixel (format MLX)
 */
void	put_pixel(t_image *img, int x, int y, int color)
{
	char	*dst;

	if (x < 0 || x >= WIDTH || y < 0 || y >= HEIGHT)
		return ;
	dst = img->addr + (y * img->line_len + x * (img->bpp / 8));
	*(unsigned int *)dst = color;
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   add_textures.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: broboeuf <broboeuf@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/18 20:36:08 by broboeuf          #+#    #+#             */
/*   Updated: 2025/07/18 23:12:17 by broboeuf         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cube3d.h"

/**
 * Charge la texture nord et la stocke dans la structure du jeu
 * @param line ligne contenant le chemin vers la texture
 * @param game structure principale
 * @return 1 si succès, 0 sinon
 */
static int	add_north_texture(char *line, t_game *game)
{
	int		i;
	char	*path;

	if (game->tex_north->is_init)
		return (print_error("double definition of a texture (NO)\n", 0));
	i = 2;
	while (line[i] == ' ')
		i++;
	path = strdup_trimmed(&line[i]);
	if (!path)
		return (print_error("malloc failed\n", 0));
	if (!load_texture(game, game->tex_north, path))
	{
		free(path);
		return (0);
	}
	game->tex_north->is_init = 1;
	free(path);
	return (1);
}

/**
 * Charge la texture sud
 */
static int	add_south_texture(char *line, t_game *game)
{
	int		i;
	char	*path;

	if (game->tex_south->is_init)
		return (print_error("double definition of a texture (SO)\n", 0));
	i = 2;
	while (line[i] == ' ')
		i++;
	path = strdup_trimmed(&line[i]);
	if (!path)
		return (print_error("malloc failed\n", 0));
	if (!load_texture(game, game->tex_south, path))
	{
		free(path);
		return (0);
	}
	game->tex_south->is_init = 1;
	free(path);
	return (1);
}

/**
 * Charge la texture est
 */
static int	add_east_texture(char *line, t_game *game)
{
	int		i;
	char	*path;

	if (game->tex_east->is_init)
		return (print_error("double definition of a texture (EA)\n", 0));
	i = 2;
	while (line[i] == ' ')
		i++;
	path = strdup_trimmed(&line[i]);
	if (!path)
		return (print_error("malloc failed\n", 0));
	if (!load_texture(game, game->tex_east, path))
	{
		free(path);
		return (0);
	}
	game->tex_east->is_init = 1;
	free(path);
	return (1);
}

/**
 * Charge la texture ouest
 */
static int	add_west_texture(char *line, t_game *game)
{
	int		i;
	char	*path;

	if (game->tex_west->is_init)
		return (print_error("double definition of a texture (WE)\n", 0));
	i = 2;
	while (line[i] == ' ')
		i++;
	path = strdup_trimmed(&line[i]);
	if (!path)
		return (print_error("malloc failed\n", 0));
	if (!load_texture(game, game->tex_west, path))
	{
		free(path);
		return (0);
	}
	game->tex_west->is_init = 1;
	free(path);
	return (1);
}

/**

	* Analyse une ligne de type texture (NO/SO/WE/EA) et appelle la fonction adaptée
 * @param game structure principale
 * @param line ligne du fichier .cub
 * @return 1 si texture ajoutée, 0 si erreur, -1 si ligne non reconnue
 */
int	add_texture(t_game *game, char *line)
{
	if (ft_strncmp(line, "NO ", 3) == 0)
		return (add_north_texture(line, game));
	else if (ft_strncmp(line, "SO ", 3) == 0)
		return (add_south_texture(line, game));
	else if (ft_strncmp(line, "WE ", 3) == 0)
		return (add_west_texture(line, game));
	else if (ft_strncmp(line, "EA ", 3) == 0)
		return (add_east_texture(line, game));
	return (-1);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   charactere.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: broboeuf <broboeuf@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/18 20:33:50 by broboeuf          #+#    #+#             */
/*   Updated: 2025/07/18 20:59:27 by broboeuf         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cube3d.h"

/**
 * Retourne l’orientation du joueur en radians selon la lettre (N/S/E/W)
 * @param c caractère représentant l’orientation sur la carte
 * @return angle en radians
 */
static double	get_player_orientation(char c)
{
	if (c == 'N')
		return (3 * M_PI_2);
	else if (c == 'S')
		return (M_PI_2);
	else if (c == 'E')
		return (0.0);
	else if (c == 'W')
		return (M_PI);
	return (3 * M_PI_2);
}

/**
 * Initialise la position de départ du joueur dans la structure de jeu
 * - Cherche la lettre N/S/E/W sur la carte
 * - Calcule la position en pixels (centrée dans la case)
 * - Définit la direction en radians
 * @param game structure principale du jeu
 */
void	get_player_start(t_game *game)
{
	int	i;
	int	j;

	i = 0;
	while (game->map[i])
	{
		j = 0;
		while (game->map[i][j])
		{
			if (game->map[i][j] == 'N' || game->map[i][j] == 'S'
				|| game->map[i][j] == 'E' || game->map[i][j] == 'W')
			{
				game->player.map_pos.x = j * CUBE_SIZE + CUBE_SIZE / 2;
				game->player.map_pos.y = i * CUBE_SIZE + CUBE_SIZE / 2;
				game->player.dir = get_player_orientation(game->map[i][j]);
				game->player.speed = SPEED;
				return ;
			}
			j++;
		}
		i++;
	}
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   colors.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: broboeuf <broboeuf@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/18 20:31:19 by broboeuf          #+#    #+#             */
/*   Updated: 2025/07/18 22:40:41 by broboeuf         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cube3d.h"

/**
 * Vérifie si la chaîne de caractères contient une couleur valide
 * La chaîne peut contenir des espaces, mais uniquement des chiffres sinon
 * @param str chaîne à analyser
 * @return valeur entière de la couleur ou -1 si invalide
 */
static int	parse_color_component(char *str)
{
	char	*tmp;
	int		i;
	int		col;

	i = 0;
	while (str[i] == ' ')
		i++;
	if (strlen_without_nl(&str[i]) == 0)
		return (-1);
	tmp = strdup_trimmed(&str[i]);
	i = 0;
	while (tmp[i] && ft_isdigit(tmp[i]))
		i++;
	while (tmp[i])
	{
		if (tmp[i] != ' ')
		{
			free(tmp);
			return (-1);
		}
		i++;
	}
	col = ft_atoi(tmp);
	free(tmp);
	return (col);
}

/**
 * Convertit une chaîne "R,G,B" en une couleur MLX
 * @param str chaîne représentant une couleur (ex: "220,100,0")
 * @return couleur MLX ou -1 si erreur
 */
static int	parse_rgb_color(char *str)
{
	int		r;
	int		g;
	int		b;
	char	**parts;

	parts = ft_split(str, ',');
	if (!parts)
		return (print_error("malloc failed\n", -1));
	if (ft_char_array_len(parts) != 3)
	{
		free_allocated_array(&parts, 0);
		return (print_error("invalid color format\n", -1));
	}
	r = parse_color_component(parts[0]);
	g = parse_color_component(parts[1]);
	b = parse_color_component(parts[2]);
	free_allocated_array(&parts, 0);
	if (r < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255)
		return (print_error("invalid color\n", -1));
	return (create_color(0, r, g, b));
}

/**
 * Ajoute la couleur du sol (F) à la structure du jeu
 * @param line ligne contenant la couleur
 * @param game structure principale
 * @return 1 en cas de succès, 0 sinon
 */
static int	add_floor_color(char *line, t_game *game)
{
	int	i;
	int	col;

	if (game->floor_color != -1)
		return (print_error("double definition of a color (F)\n", 0));
	i = 1;
	while (line[i] == ' ')
		i++;
	col = parse_rgb_color(&line[i]);
	if (col < 0)
		return (0);
	game->floor_color = col;
	return (1);
}

/**
 * Ajoute la couleur du plafond (C) à la structure du jeu
 * @param line ligne contenant la couleur
 * @param game structure principale
 * @return 1 en cas de succès, 0 sinon
 */
static int	add_ceiling_color(char *line, t_game *game)
{
	int	i;
	int	col;

	if (game->ceiling_color != -1)
		return (print_error("double definition of a color (C)\n", 0));
	i = 1;
	while (line[i] == ' ')
		i++;
	col = parse_rgb_color(&line[i]);
	if (col < 0)
		return (0);
	game->ceiling_color = col;
	return (1);
}

/**
 * Analyse une ligne pour ajouter une couleur (sol ou plafond)
 * @param game structure principale
 * @param line ligne issue du fichier .cub
 * @return 1 si succès, 0 sinon, -1 si ligne non reconnue
 */
int	add_color(t_game *game, char *line)
{
	if (ft_strncmp(line, "F ", 2) == 0)
		return (add_floor_color(line, game));
	else if (ft_strncmp(line, "C ", 2) == 0)
		return (add_ceiling_color(line, game));
	return (-1);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   law.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: broboeuf <broboeuf@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/18 20:35:01 by broboeuf          #+#    #+#             */
/*   Updated: 2025/07/18 23:09:25 by broboeuf         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cube3d.h"

/**
 * Vérifie si toutes les textures et couleurs ont bien été chargées
 * @param game structure principale
 * @return 1 si tout est présent, 0 sinon
 */
int	textures_colors_complete(t_game *game)
{
	if (game->floor_color < 0 || game->ceiling_color < 0)
		return (0);
	if (!game->tex_north->img || !game->tex_south->img || !game->tex_east->img
		|| !game->tex_west->img)
		return (0);
	return (1);
}

/**
 * Vérifie que la carte contient exactement un joueur
 * @param map tableau 2D représentant la carte
 * @return 1 si un seul joueur, 0 sinon (erreur)
 */
int	map_have_one_player(char **map)
{
	int	i;
	int	j;
	int	player_found;

	player_found = 0;
	i = 0;
	while (map[i])
	{
		j = 0;
		while (map[i][j])
		{
			if (!player_found && is_player_char(map[i][j]))
				player_found = 1;
			else if (player_found && is_player_char(map[i][j]))
				return (print_error("too many players\n", 0));
			j++;
		}
		i++;
	}
	if (!player_found)
		return (print_error("no player specified in map description\n", 0));
	return (1);
}

/**
 * Vérifie que les cases autour d’un point sont valides (pas ouvertes)
 * @param map carte
 * @param i ligne
 * @param j colonne
 * @return 1 si les cases autour sont valides, 0 sinon
 */
int	valid_surroundings(char **map, int i, int j)
{
	if ((i == 0 || j == 0) && map[i][j] == '0')
		return (0);
	if (map[i - 1][j] == ' ' || map[i + 1][j] == ' ' || map[i][j - 1] == ' '
		|| map[i][j + 1] == ' ' || !map[i - 1][j] || !map[i + 1][j] || !map[i][j
		- 1] || !map[i][j + 1])
		return (0);
	return (1);
}

/**

	* Vérifie que la carte est bien fermée par des murs (aucun espace autour d’un 0 ou d’un joueur)
 * @param map tableau 2D représentant la carte
 * @return 1 si la carte est bien fermée, 0 sinon
 */
int	is_map_closed(char **map)
{
	int	i;
	int	j;

	i = 0;
	while (map[i])
	{
		j = 0;
		while (map[i][j])
		{
			if (ft_strchr("NSWE", map[i][j]) && !valid_surroundings(map, i, j))
				return (print_error("map is not closed\n", 0));
			if (map[i][j] == '0' && !valid_surroundings(map, i, j))
				return (print_error("map is not closed\n", 0));
			j++;
		}
		i++;
	}
	return (1);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing_map.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: broboeuf <broboeuf@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/18 20:32:13 by broboeuf          #+#    #+#             */
/*   Updated: 2025/07/18 23:08:43 by broboeuf         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cube3d.h"

/**
 * Analyse une ligne du fichier .cub
 * - Si c’est une texture : la charge
 * - Si c’est une couleur : la stocke
 * - Sinon, si c’est une ligne de map : prépare largeur/hauteur
 * @param line ligne à analyser
 * @param game structure principale
 * @return 1 si succès, 0 si erreur
 */
static int	parse_line(char *line, t_game *game)
{
	static int	max_width = 0;
	static int	height = 0;
	int			add_t;
	int			add_c;

	if (!line || line[0] == '\0' || line[0] == '\n')
		return (1);
	add_t = add_texture(game, line);
	if (add_t == 1 || add_t == 0)
		return (add_t);
	add_c = add_color(game, line);
	if (add_c == 1 || add_c == 0)
		return (add_c);
	if (textures_colors_complete(game) && is_player_char(line[0]))
	{
		height++;
		if ((int)strlen_without_nl(line) > max_width)
			max_width = strlen_without_nl(line);
	}
	else
		return (print_error("invalid character found in file\n", 0));
	game->map_height = height + 1;
	game->map_width = max_width;
	return (1);
}

/**
 * Remplit une ligne de la carte dans le tableau
 * Remplace les caractères invalides ou manquants par des espaces
 * @param line ligne du fichier
 * @param game structure du jeu
 * @param row index de la ligne dans le tableau
 * @return 1 si succès, 0 si erreur
 */
static int	fill_map_row(char *line, t_game *game, int row)
{
	int	i;

	i = 0;
	while (line[i] && line[i] != '\n')
	{
		if (line[i] == ' ' || line[i] == '1' || line[i] == '0' || line[i] == 'N'
			|| line[i] == 'S' || line[i] == 'E' || line[i] == 'W')
			game->map[row][i] = line[i];
		else
			return (print_error("invalid character in map description\n", 0));
		i++;
	}
	while (i < game->map_width)
	{
		game->map[row][i] = ' ';
		i++;
	}
	game->map[row][i] = '\0';
	return (1);
}

/**
 * Remplit le tableau de la carte en lisant le fichier
 * @param path chemin du fichier .cub
 * @param game structure du jeu
 * @return 1 si succès, 0 sinon
 */
static int	fill_map_array(char *path, t_game *game)
{
	int		fd;
	char	*line;
	int		i;

	fd = open(path, O_RDONLY);
	if (fd == -1)
		return (print_error("unable to open map\n", 0));
	line = "";
	i = 0;
	while (line)
	{
		line = get_next_line(fd);
		if (is_map_line(line))
		{
			if (!fill_map_row(line, game, i++))
			{
				free(line);
				return (close(fd));
			}
		}
		free(line);
	}
	close(fd);
	return (1);
}

/**
 * Parcourt le fichier pour récupérer textures, couleurs et dimensions
 * @param path chemin du fichier .cub
 * @param game structure du jeu
 * @return 1 si succès, 0 sinon
 */
static int	scan_map(char *path, t_game *game)
{
	int		fd;
	char	*line;
	int		err;

	err = 0;
	fd = open(path, O_RDONLY);
	if (fd == -1)
		return (print_error("unable to open map\n", 0));
	if (!init_game_data(game))
		return (0);
	line = "";
	while (line)
	{
		line = get_next_line(fd);
		if (!err && !parse_line(line, game))
			err = 1;
		free(line);
	}
	close(fd);
	if (err)
		return (free_textures(game));
	return (1);
}

/**
 * Parse entièrement un fichier .cub et remplit la structure de jeu
 * - Récupère textures, couleurs, carte, position du joueur
 * - Vérifie la validité de la map
 * @param path chemin vers le fichier .cub
 * @param game structure principale
 * @return 1 si succès, 0 sinon
 */
int	parse_map(char *path, t_game *game)
{
	if (!scan_map(path, game))
		return (0);
	if (!init_map_array(game, game->map_height, game->map_width))
		return (free_textures(game));
	if (fill_map_array(path, game) <= 0)
	{
		free_allocated_array(&game->map, 0);
		return (free_textures(game));
	}
	if (!map_have_one_player(game->map))
	{
		free_allocated_array(&game->map, 0);
		return (free_textures(game));
	}
	if (!is_map_closed(game->map))
	{
		free_allocated_array(&game->map, 0);
		return (free_textures(game));
	}
	get_player_start(game);
	return (1);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   block.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: broboeuf <broboeuf@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/18 20:48:28 by broboeuf          #+#    #+#             */
/*   Updated: 2025/07/18 20:59:40 by broboeuf         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cube3d.h"

/**
 * Vérifie s'il y a un mur ou un vide en bas du joueur
 * @param game structure principale
 * @param new_x nouvelle coordonnée x (pixels)
 * @param new_y nouvelle coordonnée y (pixels)
 * @return 1 si bloqué, 0 sinon
 */
int	is_blocking_down(t_game *game, int new_x, int new_y)
{
	new_x += 16;
	new_y += 16;
	new_x /= CUBE_SIZE;
	new_y /= CUBE_SIZE;
	if (new_x < 0 || new_x >= game->map_width || new_y < 0
		|| new_y >= game->map_height)
		return (1);
	if (game->map[new_y][new_x] == '1' || game->map[new_y + 1][new_x
		+ 1] == ' ')
		return (1);
	return (0);
}

/**
 * Vérifie s'il y a un mur ou un vide au-dessus du joueur
 */
int	is_blocking_up(t_game *game, int new_x, int new_y)
{
	new_x -= 16;
	new_y -= 16;
	new_x /= CUBE_SIZE;
	new_y /= CUBE_SIZE;
	if (new_x < 0 || new_x >= game->map_width || new_y < 0
		|| new_y >= game->map_height)
		return (1);
	if (game->map[new_y][new_x] == '1' || game->map[new_y + 1][new_x
		+ 1] == ' ')
		return (1);
	return (0);
}

/**
 * Vérifie s'il y a un mur ou un vide à droite du joueur
 */
int	is_blocking_right(t_game *game, int new_x, int new_y)
{
	new_x += 16;
	new_y -= 16;
	new_x /= CUBE_SIZE;
	new_y /= CUBE_SIZE;
	if (new_x < 0 || new_x >= game->map_width || new_y < 0
		|| new_y >= game->map_height)
		return (1);
	if (game->map[new_y][new_x] == '1' || game->map[new_y + 1][new_x
		+ 1] == ' ')
		return (1);
	return (0);
}

/**
 * Vérifie s'il y a un mur ou un vide à gauche du joueur
 */
int	is_blocking_left(t_game *game, int new_x, int new_y)
{
	new_x -= 16;
	new_y += 16;
	new_x /= CUBE_SIZE;
	new_y /= CUBE_SIZE;
	if (new_x < 0 || new_x >= game->map_width || new_y < 0
		|| new_y >= game->map_height)
		return (1);
	if (game->map[new_y][new_x] == '1' || game->map[new_y + 1][new_x
		+ 1] == ' ')
		return (1);
	return (0);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   errors.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: broboeuf <broboeuf@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/18 20:44:48 by broboeuf          #+#    #+#             */
/*   Updated: 2025/07/18 20:59:44 by broboeuf         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cube3d.h"

/**
 * Affiche un message d'erreur en rouge dans le terminal
 * @param str message à afficher
 * @param exit_status code de retour
 * @return exit_status (permet d'enchaîner avec un return)
 */
int	print_error(char *str, int exit_status)
{
	ft_putstr_fd("\033[31mError\033[39m\n", 2);
	ft_putstr_fd(str, 2);
	return (exit_status);
}

/**
 * Vérifie si un nom de fichier se termine par ".cub"
 * @param filename nom du fichier à vérifier
 * @return 1 si l’extension est correcte, 0 sinon
 */
int	is_file_extension_correct(char *filename)
{
	int	i;

	i = 0;
	while (filename[i])
		i++;
	if (i < 5)
		return (0);
	if (filename[i - 1] != 'b' || filename[i - 2] != 'u' || filename[i
		- 3] != 'c' || filename[i - 4] != '.')
		return (0);
	return (1);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: broboeuf <broboeuf@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/18 20:46:00 by broboeuf          #+#    #+#             */
/*   Updated: 2025/07/18 20:59:46 by broboeuf         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cube3d.h"

/**
 * Libère toutes les ressources allouées dans la structure principale
 * Détruit les textures, images, fenêtre, display et quitte le programme
 * @param game structure principale du jeu
 * @return toujours 0 (inutile car exit)
 */
int	free_game(t_game *game)
{
	int	i;

	free(game->rays);
	i = 0;
	while (i < game->map_height)
	{
		free(game->map[i]);
		i++;
	}
	free(game->map);
	mlx_destroy_image(game->mlx, game->tex_north->img);
	mlx_destroy_image(game->mlx, game->tex_south->img);
	mlx_destroy_image(game->mlx, game->tex_east->img);
	mlx_destroy_image(game->mlx, game->tex_west->img);
	free(game->tex_north);
	free(game->tex_south);
	free(game->tex_east);
	free(game->tex_west);
	if (game->screen.img)
		mlx_destroy_image(game->mlx, game->screen.img);
	mlx_destroy_window(game->mlx, game->win);
	mlx_destroy_display(game->mlx);
	free(game->mlx);
	exit(EXIT_SUCCESS);
	return (0);
}

/**
 * Libère un tableau de chaînes alloué dynamiquement
 * @param array pointeur vers le tableau
 * @param is_err 1 pour afficher une erreur, 0 sinon
 * @return -1 si erreur, 0 sinon
 */
int	free_allocated_array(char ***array, int is_err)
{
	int	i;

	if (!*array)
		return (0);
	i = 0;
	while ((*array)[i])
	{
		free((*array)[i]);
		i++;
	}
	free(*array);
	if (is_err)
		return (print_error("invalid caracter detected\n", -1));
	return (0);
}

/**
 * Détruit les textures chargées et libère leur structure
 * @param game structure principale
 * @return toujours 0
 */
int	free_textures(t_game *game)
{
	if (game->tex_north->is_init)
		mlx_destroy_image(game->mlx, game->tex_north->img);
	if (game->tex_south->is_init)
		mlx_destroy_image(game->mlx, game->tex_south->img);
	if (game->tex_east->is_init)
		mlx_destroy_image(game->mlx, game->tex_east->img);
	if (game->tex_west->is_init)
		mlx_destroy_image(game->mlx, game->tex_west->img);
	free(game->tex_north);
	free(game->tex_south);
	free(game->tex_east);
	free(game->tex_west);
	return (0);
}

/**
 * Libère partiellement un tableau jusqu’à un certain index
 * @param array tableau à libérer
 * @param last_alloc dernier index alloué
 */
void	free_partial(char ***array, int last_alloc)
{
	int	i;

	i = 0;
	while (i < last_alloc)
	{
		free((*array)[i]);
		i++;
	}
	free(*array);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init_walls.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: broboeuf <broboeuf@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/18 20:47:45 by broboeuf          #+#    #+#             */
/*   Updated: 2025/07/18 20:59:49 by broboeuf         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cube3d.h"

/**
 * Initialise la texture nord (NO)
 * @param game structure principale
 * @return 1 si succès, 0 sinon
 */
int	init_tex_north(t_game *game)
{
	game->tex_north = malloc(sizeof(t_texture));
	if (!game->tex_north)
		return (print_error("malloc failed\n", 0));
	game->tex_north->is_init = 0;
	return (1);
}

/**
 * Initialise la texture sud (SO)
 * @param game structure principale
 * @return 1 si succès, 0 sinon
 */
int	init_tex_south(t_game *game)
{
	game->tex_south = malloc(sizeof(t_texture));
	if (!game->tex_south)
	{
		free(game->tex_north);
		return (print_error("malloc failed\n", 0));
	}
	game->tex_south->is_init = 0;
	return (1);
}

/**
 * Initialise la texture est (EA)
 * @param game structure principale
 * @return 1 si succès, 0 sinon
 */
int	init_tex_east(t_game *game)
{
	game->tex_east = malloc(sizeof(t_texture));
	if (!game->tex_east)
	{
		free(game->tex_north);
		free(game->tex_south);
		return (print_error("malloc failed\n", 0));
	}
	game->tex_east->is_init = 0;
	return (1);
}

/**
 * Initialise la texture ouest (WE)
 * @param game structure principale
 * @return 1 si succès, 0 sinon
 */
int	init_tex_west(t_game *game)
{
	game->tex_west = malloc(sizeof(t_texture));
	if (!game->tex_west)
	{
		free(game->tex_north);
		free(game->tex_south);
		free(game->tex_east);
		return (print_error("malloc failed\n", 0));
	}
	game->tex_west->is_init = 0;
	return (1);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   maps.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: broboeuf <broboeuf@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/18 20:49:33 by broboeuf          #+#    #+#             */
/*   Updated: 2025/07/18 22:28:51 by broboeuf         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cube3d.h"

/**
 * Vérifie si le caractère correspond à une orientation du joueur
 * @param c caractère à tester
 * @return 1 si c est 'N', 'S', 'E' ou 'W', 0 sinon
 */
int	is_player_char(char c)
{
	if (c == 'N' || c == 'S' || c == 'E' || c == 'W')
		return (1);
	return (0);
}

/**
 * Vérifie si le caractère est valide dans une carte
 * @param c caractère à tester
 * @return 1 si valide (' ', '0', '1', ou joueur), 0 sinon
 */
int	is_map_char(char c)
{
	if (c == ' ' || c == '0' || c == '1' || is_player_char(c))
		return (1);
	return (0);
}

/**
 * Vérifie si une ligne appartient à la description de la carte
 * @param line ligne du fichier .cub
 * @return 1 si c'est une ligne de carte, 0 sinon
 */
int	is_map_line(char *line)
{
	if (!line || line[0] == '\0' || line[0] == '\n')
		return (0);
	if (ft_strncmp(line, "NO ", 3) == 0)
		return (0);
	if (ft_strncmp(line, "SO ", 3) == 0)
		return (0);
	if (ft_strncmp(line, "WE ", 3) == 0)
		return (0);
	if (ft_strncmp(line, "EA ", 3) == 0)
		return (0);
	if (ft_strncmp(line, "F ", 2) == 0)
		return (0);
	if (ft_strncmp(line, "C ", 2) == 0)
		return (0);
	return (1);
}

/**
 * Initialise la structure de jeu (textures, couleurs, dimensions, joueur)
 * @param game structure principale
 * @return 1 si succès, 0 sinon
 */
int	init_game_data(t_game *game)
{
	if (!init_no_text(game) || !init_so_text(game) || !init_ea_text(game)
		|| !init_we_text(game))
		return (0);
	game->floor_color = -1;
	game->ceiling_color = -1;
	game->map_width = 0;
	game->map_height = 0;
	game->map = NULL;
	game->player.map_pos.x = 0;
	game->player.map_pos.y = 0;
	game->player.dir = 0;
	game->rays = NULL;
	return (1);
}

/**
 * Alloue le tableau 2D de la carte
 * @param game structure principale
 * @param height hauteur de la carte
 * @param width largeur de la carte
 * @return 1 si succès, 0 sinon
 */
int	init_map_array(t_game *game, int height, int width)
{
	int	i;

	game->map = malloc(sizeof(char *) * (height + 1));
	if (!game->map)
		return (free_allocated_text(game), print_error("malloc failed\n", 0));
	game->map[height] = NULL;
	i = 0;
	while (i < height)
	{
		game->map[i] = malloc(sizeof(char) * (width + 1));
		if (!game->map[i])
			return (free_partial_array(&game->map, i),
				print_error("malloc failed\n", 0));
		game->map[i][width] = '\0';
		while ((i == height - 1) && width > 0)
			game->map[i][--width] = ' ';
		i++;
	}
	return (1);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   move.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: broboeuf <broboeuf@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/18 20:51:25 by broboeuf          #+#    #+#             */
/*   Updated: 2025/07/18 22:32:23 by broboeuf         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cube3d.h"

/**
 * Vérifie si une position est bloquée (mur ou bordure)
 * @param game structure principale du jeu
 * @param x coordonnée x de la position à tester
 * @param y coordonnée y de la position à tester
 * @return 1 si bloqué, 0 sinon
 */
static int	is_position_blocked(t_game *game, int x, int y)
{
	if (is_blocked_top(game, x, y))
		return (1);
	if (is_blocked_bottom(game, x, y))
		return (1);
	if (is_blocked_right(game, x, y))
		return (1);
	if (is_blocked_left(game, x, y))
		return (1);
	return (0);
}

/**
 * Déplace le joueur vers l'avant
 * @param game structure principale du jeu
 */
void	move_player_forward(t_game *game)
{
	double	nx;
	double	ny;

	mlx_destroy_image(game->mlx, game->screen.img);
	nx = game->player.map_pos.x + cos(game->player.dir) * game->player.speed;
	ny = game->player.map_pos.y + sin(game->player.dir) * game->player.speed;
	if (!is_position_blocked(game, nx, ny))
	{
		game->player.map_pos.x = nx;
		game->player.map_pos.y = ny;
	}
	render_frame(game);
}

/**
 * Déplace le joueur vers l'arrière
 * @param game structure principale du jeu
 */
void	move_player_backward(t_game *game)
{
	double	nx;
	double	ny;

	mlx_destroy_image(game->mlx, game->screen.img);
	nx = game->player.map_pos.x - cos(game->player.dir) * game->player.speed;
	ny = game->player.map_pos.y - sin(game->player.dir) * game->player.speed;
	if (!is_position_blocked(game, nx, ny))
	{
		game->player.map_pos.x = nx;
		game->player.map_pos.y = ny;
	}
	render_frame(game);
}
/**
 * Déplace le joueur vers la gauche (strafe gauche)
 * @param game structure principale du jeu
 */
void	move_player_left(t_game *game)
{
	double	nx;
	double	ny;
	double	s;

	s = game->player.speed;
	mlx_destroy_image(game->mlx, game->screen.img);
	nx = game->player.map_pos.x - cos(game->player.dir + M_PI_2) * s;
	ny = game->player.map_pos.y - sin(game->player.dir + M_PI_2) * s;
	if (!is_position_blocked(game, nx, ny))
	{
		game->player.map_pos.x = nx;
		game->player.map_pos.y = ny;
	}
	render_frame(game);
}

/**
 * Déplace le joueur vers la droite (strafe droite)
 * @param game structure principale du jeu
 */
void	move_player_right(t_game *game)
{
	double	nx;
	double	ny;
	double	s;

	s = game->player.speed;
	mlx_destroy_image(game->mlx, game->screen.img);
	nx = game->player.map_pos.x + cos(game->player.dir + M_PI_2) * s;
	ny = game->player.map_pos.y + sin(game->player.dir + M_PI_2) * s;
	if (!is_position_blocked(game, nx, ny))
	{
		game->player.map_pos.x = nx;
		game->player.map_pos.y = ny;
	}
	render_frame(game);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   strings.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: broboeuf <broboeuf@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/18 20:55:53 by broboeuf          #+#    #+#             */
/*   Updated: 2025/07/18 20:59:58 by broboeuf         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cube3d.h"

/**
 * Retourne la longueur de la chaîne sans inclure le caractère '\n'
 * @param str chaîne de caractères
 * @return longueur sans le '\n'
 */
unsigned int	strlen_without_nl(const char *str)
{
	unsigned int	i;

	i = 0;
	while (str[i] != '\0' && str[i] != '\n')
		i++;
	return (i);
}

/**
 * Duplique une chaîne sans les espaces finaux ni le caractère '\n'
 * @param str chaîne de base
 * @return chaîne allouée nettoyée
 */
char	*strdup_trimmed(const char *str)
{
	char			*result;
	unsigned int	i;
	unsigned int	len;

	len = strlen_without_nl(str);
	if (len == 1 && str[0] == '\n')
		return (ft_strdup(""));
	while (str[len] == '\0' || str[len] == '\n' || str[len] == ' ')
		len--;
	result = malloc(sizeof(char) * (len + 2));
	if (!result)
		return (NULL);
	i = 0;
	while (i < len + 1)
	{
		result[i] = str[i];
		i++;
	}
	result[i] = '\0';
	return (result);
}

/**
 * Calcule la longueur d'un tableau de chaînes null-terminé
 * @param array tableau de chaînes
 * @return nombre de lignes
 */
int	string_array_length(char **array)
{
	int	i;

	i = 0;
	while (array[i] != NULL)
		i++;
	return (i);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: broboeuf <broboeuf@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/18 20:56:57 by broboeuf          #+#    #+#             */
/*   Updated: 2025/07/18 22:33:45 by broboeuf         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cube3d.h"

/**
 * Point d’entrée principal du programme cub3D
 * Vérifie les arguments, initialise la fenêtre, parse la carte,
 * puis lance la boucle principale du jeu.
 */
int	main(int argc, char **argv)
{
	t_game	game;

	if (argc != 2)
		return (print_error("Usage: ./cub3D path_to_map\n", EXIT_FAILURE));
	if (!is_file_extension_correct(argv[1]))
		return (print_error("Wrong file extension\n", EXIT_FAILURE));
	game.mlx = mlx_init();
	if (!game.mlx)
		return (print_error("mlx_init() failed\n", EXIT_FAILURE));
	game.win = mlx_new_window(game.mlx, WIDTH, HEIGHT, "cub3D");
	if (!game.win)
	{
		mlx_destroy_display(game.mlx);
		free(game.mlx);
		return (print_error("mlx_new_window() failed\n", EXIT_FAILURE));
	}
	if (!parse_map(argv[1], &game))
	{
		mlx_destroy_window(game.mlx, game.win);
		mlx_destroy_display(game.mlx);
		free(game.mlx);
		return (EXIT_FAILURE);
	}
	game_loop(&game);
	return (0);
}
